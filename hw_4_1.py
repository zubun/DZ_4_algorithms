#1. Проанализировать скорость и сложность одного любого алгоритма, разработанных в рамках домашнего задания первых трех уроков.

import heapq


def random_list():
    import random
    par_1 = int(input(f'Введите нижнюю границу диапазона: '))
    par_2 = int(input(f'Введите верхнюю границу диапазона: '))
    par_3 = int(input(f'Введите кол-во чисел в списке: '))
    list = []
    for i in range(par_3):
        list.append(random.randint(par_1, par_2))
    return list


def main():
    range_ = random_list()
    min_ = heapq.nsmallest(2, range_)
    print(f' Из списка: *range_ два наименьших элемента равны {min_}.')



# Вариант 2.


def main_1():
    a = random_list()
    # print(*a)
    print(*sorted(a)[:2])


import cProfile

cProfile.run('main()')
cProfile.run('main_1()')

# При первом варианте программы в среднем скорость срабатывания варьируется в пределах 0,1 sec если не рассматривать отработку функции
# random_list()(выполнение этой цункции во многом зависит от скорости ввода значений в диалоге). При равных условиях скорость срабатывания
# второго варианта программы находится в пределах 1,3 sec, что свидетельствует о том что первая программа работает в 13 раз быстрее второй.